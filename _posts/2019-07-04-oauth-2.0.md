---
layout: post
title: "Brief introduction to OAuth 2.0"
categories: security
---

OAuth 2.0 is an open standard for authorization, published as [RFC 6749](https://tools.ietf.org/html/rfc6749) and [RFC 6750](https://tools.ietf.org/html/rfc6750) in October 2012.

OAuth 2.0 enables a third-party application (_client_) to obtain limited access (via an _access token_) to an HTTP service (_resource_), either on behalf of an end-user (_resource owner_) or by allowing the third-party application to obtain access on its own behalf. This specification replaces and obsoletes the OAuth 1.0 protocol.

# Roles

OAuth defines four roles:
- resource owner (eg. the end-user)
- resource server (the server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens)
- client (the application making protected resource requests on behalf of the resource owner)
- authorization server (the server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization)

# Obtaining Authorization

To request an _access token_, the _client_ obtains authorization from the _resource owner_. The authorization is expressed in the form of an _authorization grant_, which the _client_ uses to request the _access token_.

OAuth defines four grant types (plus and extension mechanism for defining additional grant types):
- authorization code
- resource owner password credentials
- client credentials
- implicit

The _authorization code grant_ is the most used type, for apps running on a web server, browser-based and mobile apps. For other use cases, see [here](https://auth0.com/docs/api-auth/which-oauth-flow-to-use) a decision tree about which flow to use.

## Authorization Code Grant Flow

The _authorization code grant_ type is used to obtain both _access tokens_ and _refresh tokens_ and is optimized for confidential clients. Since this is a redirection-based flow, the client must be capable of interacting with the resource owner's user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the _authorization server_.

Check this on [WebSequenceDiagrams](https://www.websequencediagrams.com/) - TODO: create an account and link the image directly:

```
title Authorization Code Grant Flow

participant "Resource Owner" as RO
participant "Client" as C
participant "Authorization Server" as AS
participant "Resource Server" as RS

C->+AS: Authorization Code Request
RO->AS: Login & Consent
AS-->>-C: Authorization Code Response
C->+AS: Exchange Code for Access Token
AS-->>-C: Access Token [+ Refresh Token]
loop
C->+RS: Resource Request with Access Token
RS-->>-C: Resource Response with Data
end
```

# Read More

OAuth 2.0 describes patterns for granting authorization but does not define how to actually perform authentication. One interesting and useful extension of OAuth 2.0 is the OpenID Connect protocol.

## OpenID Connect

[OpenID Connect](http://openid.net/connect/) 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.

# Reference

- [OAuth 2.0 | oauth.net](https://oauth.net/2/)
- [RFC 6749 - The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749)
- [RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://tools.ietf.org/html/rfc6750)
- [OAuth 2.0 Simplified | Aaron Parecki](https://aaronparecki.com/oauth-2-simplified/)
- [OAuth 2.0 Authorization Framework | Auth0 Docs](https://auth0.com/docs/protocols/oauth2)
